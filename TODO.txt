REMEMBER: GET IT UP AND RUNNING ASAP (details and optimizations can come later)

    PITCH: An application teaching goemetric transformations using puzzles, but the app itself is a puzzle the user must explore to unravel
    GOAL: A vertical slice of the entire game - one complete cube (with other cubes grayed out so you can use them)

            look at notebook for design notes
                the puzzle interaction needs to be clarified and fleshed out ( main problem is I don't like solving puzzles in 3 dimensions)
                    solving in 3 dimensions requires too much input to see all possibilities, whereas for 2-d puzzles all the information
                    can be present on screen at one time.  In real life this is less of a problem since rotating a rubrik's cube with 
                    your hands is significantly easier than doing the same on a digital screen (due to the simple fact that we use our hands
                    on a daily basis and only use my application / mouse and keyboard for limited time a day)

                    The third dimension is more useful for exploration / building atmosphere than to solve complex puzzles (at least with the current 
                        limitations in user input - touchscreen, mouse, keyboard)  That will change once VR tech becomes more commonplace and advanced

                    -solving fractal puzzles is mostly clear (connecting colored line segments across surface of a square)
                    -solving cube faces puzzle is a bit fuzzy (connecting colored line segments wrapped around 6 surfaces of a cube, but requires 3-d motion????)
                    -solving 8 cubes puzzles for tesseract is very fuzzy (I don't know how I want to do this)

    THE BIG THREE:
        1. Learn NodeJS with Typescript - groundwork for stable work if this app doesn't pan out- do this for Xuan and our future
            look at TODO.text in TypescriptTest project for notes on what to do 

            Get a good web project that I can put in portfolio by the end of the month of December (nifty website for LASEPS or something would be good)
                Find some good websites to use as a starting point (consulting, marketing websites)
                keep it simple and clean - angular has all the stuff I need (probably) or even just make it in html, css and TypeScript with Node.js and Express.js
            Polish up the rigid body simulation - for potential c++ gamedev/systems/embedded jobs
            Polish up the custom software 3d rasterizer - same as above

            practice: set up linux server - how to do it??? Practice it by setting it up with different configurations (eg, for node.js, flask, docker, etc)

        2. Test on Ubuntu virtual machine  (resume download and / or install vm)
            install unbuntu on virtual machine
            clone from Squares on Github
            build and compile/link
            run
            need to test this on a regular basis - after version changes

        3. Core Puzzle Features - transformations/splitting/forming and puzzle clear/puzzleset clear (do this in the morning)

            ///////////////////////////REFACTOR///////////////////////////////////////////////////////
            Wire all that up so that fractals display correct colors - start with having them display all red or empty to find where that logic can start
                    all Fractals are reading from custom texture at the moment, but we're not setting it to any parts of the default texture, so gray
                    set up custom texture (the first 128 x 128) to red, green, blue, empty to test colors
                    Transforming a puzzle and writing to g_Data should also update the custom texture so that newly created fractals have correct color
            Move all updatesprite and update texture code to Puzzle class 
            Move all code in that rotates/reflects/translates fractals to RotateX(), ReflectY(), etc so that they update g_Data (and custom texture sheet)
            remove elements and puzzle index, etc from Fractal class that we don't use anymore

            MenuLayer::UndoResizeFractal() function is not functioning....

            What if I refactored everything so that puzzles held all element data??
              Would that make undo easier??? I could just save the undo stack as a grid
                But that would cause other problems with undo - would still need to store undo data (because deducing that by comparing current and
                previous elements would be a different type of hell).  So undo will still best be saved as UndoData

              If a fractal animation is set, always destroy/recreate it OnAnimationEnd() to avoid saving states
              setting a fractal animation will change the elements and textures in puzzle immediately, (but this won't affect current fractals)
              OnAnimationEnd will recreate the fractals with the new data that was transformed (new data is only sprite since elements is held in puzzle now)

              How would my current problem be different if I refactored the elements to puzzle?
                right now, I'm calling split fractals, merge fractals and then animate when resizing is needed for the undo pipeline 
                this wouldn't really change much besides how I look up which fractals to split/merge (since now it can be done in puzzles)
                but then would still need to iterate over fractals


              //////////////shelve this for the time being/////////////////////////////////
            ///////////////////////UNDO BUG///////////////////////////////////////////////////
            Bug recreated!
              Merge center left 4 into a 2x2.  Merge center right 4 into a 2x2.  Swap the two 2x2s
              Merge all into a 4x4
              Push undo for application to crash.  
              Also crashes if I do top middle, and bottom middle 2x2s 

            MenuLayer::UndoResizeFractals is too big and confusing - is there any way to break these up into smaller functions? Or are they too dependent?

              I suspect bug is related to splitting after check fractalB, and then trying to split again when checking fractalA afterwards


              Consider grabbing a notebook and writing out some pseudocode to cover all the cases

            ////////////////////////////////////////////////////////////////////////////////////

            Implement non-moveable colored blocks (which are the endpoints user has to connect using transformations)

            Implement completing puzzles by connecting colored blocks with non-moveable colored blocks

            How will this connect to the puzzlesets????



Set build (x86 or x64) (or should this be a build option???)

Open and build in visual studio using solutions generated by cmake to test if it works

Build on linux virtual machine to test different compiler (GCC) and the LLVM one (Clang)

Need to make sure MAX_VERTEX size in shaders are below hardware max 

Make sure I'm compile to release mode (and not debug) with optimizations turned to max
