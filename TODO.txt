REMEMBER: GET IT UP AND RUNNING ASAP (details and optimizations can come later)

    PITCH: An application teaching goemetric transformations using puzzles, but the app itself is a puzzle the user must explore to unravel

    THE BIG THREE:
        3. Core Puzzle Features - transformations/splitting/forming and puzzle clear/puzzleset clear (Spend mornings on this)

                get reflections and rotations working by first implementing collision checks with corners and edges:
                    Flick corner for rotations
                    Tap Edges (between corner collision boxes) for reflection 

                    Fractal.h
                        CornerCollision(const glm::vec2& mouse) returns an enum Corner::TopLeft (example) or Corner::None
                        EdgeCollision(const glm::vec2& mouse) returns an enum Edge::Left (example) or Edge::None

                    Mouse: (can require slightly more precision compared to touch controls)
                        Translation - drag
                        Reflection - tap on edge
                        Rotation - drag corner
                        Split - mouse wheel down
                        Form - mouse wheel up
                    Touch:
                        Translation - flick
                        Reflection - tap on edge
                        Rotation - two finger rotation
                        Split - pinch out
                        Form - pinch in

                InputQueue and CommandQueue
                    input queue processes inputs and decays inputs out of the queue when commands take too long to complete (ex: during multistep commands)
                    if the commandqueue is empty and the input queue has inputs, the next input is used to find the appropriate command and 
                        that command is then added to the commandqueue to be called

                InputQueue also should take in processed inputs (not the raw inputs) - how to process inputs?

        1. Save/load system - SDL_GetPrefPath

            Write out data to profile.json to make sure it saves correctly

            Read data in from profile.json if it exists

            Default data should also be move out of json file - should write it in c++ and compile it with executable
                so that user can't accidentally delete default data

            once I understand the parser function in json class, try to roll my own parser
                it doesn't need to be the 50,000 line beast that is the library I'm using
                make it rigid and only capable of reading/writing to the specific format for my app

        2. Audio - FMOD
            Sound is playing on translate up 
            Get music looping

        4. Stop with the unnecessary abstractions
            Clean up engine code to keep it simple like this: (no need for layers or anything right now)

                class Squares : public rose::Application {
                    public:
                        Squares() {}

                        bool Create() override {
                        }
                        bool Update() override {
                        }
                }

                int main() {
                    Squares squares;
                    if(squares.Construct(256, 240, 4, 4))
                        squares.Start();
                    return 0;
                }


                Application.h and cpp - contains Layer/Renderer/Audio/Input classes
                    Layer - all gameplay scripting
                    Input - get user inputs/events
                    Renderer - all OpenGL code
                    Audio - all FMOD code

Set build (x86 or x64) (or should this be a build option???)

Open and build in visual studio using solutions generated by cmake to test if it works

Build on linux virtual machine to test different compiler (GCC) and the LLVM one (Clang)

Need to make sure MAX_VERTEX size in shaders are below hardware max 

Make sure I'm compile to release mode (and not debug) with optimizations turned to max
