REMEMBER: GET IT UP AND RUNNING ASAP (details and optimizations can come later)

Fractals - the big one here.  The last large piece to get back to working status

    Get shader class up and running - test it
        Need to have shader set uniforms

    Create batch class to encapsulate models, vertex buffer, and index buffer, and texture
        Batch(Texture texture, Shader shader); //will need to create Shader class too
        Batch->Bind();
        Batch->UploadData();
        Batch->AddQuad()

    

    Idea: create a Batch class, and have renderer own two batches: default texture and custom texture
        in renderer DrawScene(), can Bind buffers, set data (include models/texture) and draw Batch 1
                            and then  Bind buffers, set data (incuding models/texture), and draw batch 2
    
    Finish Fractal::MakeEntityData(....)
        needs to copy texture data from default texture to custom texture

    update Texture so that we can load 1 or 2 textures when drawing (.png sprite sheet or the custom sprite sheet for fractals)
        requires two different draw calls for each of the textures
    

    Need to update renderer and have two lists of Entities to draw:
        - ones using default texture sheet
        - ones using custom texture sheet (just the fractals)

    Have Fractals of different sizes display - will need new textures
        use delegated constructors to fix constructor parameter problem

    Rewrite Fractal constructor (and class)
        the Fractal(fractal size, index, pos): Entity(...)
            size /bounding box that are passed to Entity(...) must be scaled by fractal size
            Entity will need a SetSprite() function so that we can change sprites later
                since the fractal sprite has to be custom made

            Fractal needs to call CreateTexture in constructor, and then call SetSprite() to change sprite data (in self and Entity)

            will need to create a second texture for custom sprite textures
                can use the fractal index to signify the corner of sprite sheet
                since fractals are limited to 8 x 8, we just need 32x32x64 sized sheet - a 256 x 256 sprite sheet is enough
                when creating a new fractal sprite of size 2 at index (2, 1), texture coords will start at (64, 32), and have dimensions 64x64
                need an API to create texture
                CopyTexture(destinationDataStart, sourceDataStart, texWidth, texHeight);
                will need to allocate buffer in texture class at the beginning
                will need to bind appropriate texture when drawing
                    could add extra data value to Sprite data - texture sheet0 or texture sheet 1 
        

    Pinchout and pinchin Fractals to change sizes
        First get split working (since it's easier)
            Write Puzzle::Split(Fractal* f)
            Will need to change Fractal constructor to allow different fractal sizes 
                this will require a way to create new textures....this might be tricky
            will need to write static Fractal functions that calculate fractal location based on size and target size
                

    Entity uses the singleton GetApplication() to draw
        Make a RenderCommand purely static class so that Entity can call it without needing access to application/renderer
            RenderCommand::StartScene() should also call RenderCommand::Clear() and any OpenGL commands needed before drawing
            RenderCommand::AddQuad() //just adds vertices/indices.  called by Entites in Layer::Update(....)
            RenderCommand::Draw() 
            RenderCommand::EndScene(); //should clear the index/vertex buffers/swap screen buffers and do anyother cleanup needed for OpenGL

    Renderer is bound to a context (the Window).  So who should own what?

    let's keep the singleton for now, but I might get rid of it later


    Benchmarking - use website to drag/drop JSON file
        will be interesting to see what slows down when laptop is unplugged

    1. Get Fractals responding to user input
        how should the inputdispatcher process inputs??
            write out the API I want to use in Squares.cpp to process all inputs coming in from Rose engine
            then declare/implement those functions
            InputDispatcher will also need to keep track of animation timing...
                it might be a good idea to pull all that stuff scattered all over the Layer Update() function 
                into the InputDispatcher to process
                function calls can then be used on the InputDispatcher to get necessary data

    2. Forming larger fractals and splitting into smaller fractals (this should be a command called by puzzle)

    1. Get Fractals data to read from external JSON
            how are JSON files formatted????
    2. Get Fractals data to write to external JSON

    1. Translations of fractals
    2. Rotations of fractals
    3. Reflections of fractals


Allow window scaling when the application is active
    should check online for reference material on how to change SDL2 window sizes (event)

Everything is squished when the aspect ratio is not a 480x270 ratio
    how do I fix this?  I want everything to look that same (eg same height/width ratio) regardless of window ratio
    Two things:
        1. Currently, the projection matrix in renderer is hard coded to 480x270 - need to change this to accomodate aspect ratio of window
        2. Currently, Squares.cpp uses 480x270 world space (related to projection) need to change this to accomodate aspect ratio of window
        3. Need to accomodate window scaling too

    Tests: (all squares should be squares, and rectangles should be 2:1)
        1. Check fullscreen
        2. Check windowed with 480x270 aspect ratio
        3. Check windowed with aspect ratio of 2:1
        4. Check windowed with aspect ratio of 1:2

Set build (x86 or x64) (or should this be a build option???)

Build on linux virtual machine to test different compiler (GCC)
